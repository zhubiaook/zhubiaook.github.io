<!DOCTYPE html>
<html>
  <head>
    <title>posts</title>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta http-equiv="X-UA-Compatible" content="ie=edge" />


<link rel="stylesheet" href="/assets/css/bootstrap.min.css" />
<link rel="stylesheet" href="/assets/css/layouts/main.css" />
<link rel="stylesheet" href="/assets/css/style.css" />
<link rel="stylesheet" href="/assets/css/navigators/navbar.css" />


<link href="https://fonts.googleapis.com/css2?family=Muli:wght@300;400;500;600" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.min.css" />


<link rel="icon" type="image/png" href="/assets/images/favicon.png" />


<link rel="stylesheet" href="/assets/css/style.css" />

    
    <link rel="stylesheet" href="/assets/css/layouts/list.css">
    <link rel="stylesheet" href="/assets/css/navigators/sidebar.css">


    
    
  </head>

  <body data-spy="scroll" data-target="#TableOfContents" data-offset="80">
    <div class="container-fluid bg-dimmed wrapper">
      
      
    <nav class="navbar navbar-expand-xl top-navbar final-navbar shadow">
  <div class="container">
    
    
    
      
    
    
      
    
      <button class="navbar-toggler navbar-light" id="sidebar-toggler" type="button" onclick="toggleSidebar()">
      <span class="navbar-toggler-icon"></span>
    </button>
    <a class="navbar-brand" href="https://blog.zybz.fun/">
      <img src="/assets/images/main-logo.png">blog</a>
    <button class="navbar-toggler navbar-light" id="toc-toggler" type="button" onclick="toggleTOC()">
      <span class="navbar-toggler-icon"></span>
    </button>

    <div class="collapse navbar-collapse" id="top-nav-items">
      <ul class="navbar-nav ml-auto">
      </ul>
    </div>
  </div>
  
  <img src="/assets/images/main-logo.png" class="d-none" id="main-logo">
  <img src="/assets/images/inverted-logo.png" class="d-none" id="inverted-logo">
</nav>



      
      
  <section class="sidebar-section" id="sidebar-section">
    <div class="sidebar-holder">
      <div class="sidebar" id="sidebar">
        <input type="text" value="" placeholder="Search" data-search="" id="search-box" />
        <div class="sidebar-tree">
          <ul class="tree" id="tree">
            <li id="list-heading"><a href="/posts" data-filter="all">Posts</a></li>
            <div class="subtree">
                
  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="">.Linux.LinuxSystemProgramming</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linuxsystemprogramming/memory/">memory</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/autoops/">AutoOps</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/c/">C</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/c/c_syntax/">c_syntax</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/container/">Container</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/container/docker/">Docker</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/container/docker/container_concept/">container_concept</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/container/docker/virtualmachine_container/">virtualmachine_container</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/container/istio/">Istio</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/container/kubernetes/">Kubernetes</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/container/namespaceandcgroup/">NamespaceAndCgroup</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/container/namespaceandcgroup/namespace/">namespace</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/container/network/">Network</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/container/network/tun_tap/">tun_tap</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/container/network/veth/">veth</a></li>
  


      </ul>
    </li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/database/">Database</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/linux/">Linux</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/linux/bash/">Bash</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/linux/command/">Command</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/ethtool/">ethtool</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/iftop/">iftop</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/ip/">ip</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/lsof/">lsof</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/strace/">strace</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/sysctl/">sysctl</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/tcpdump/">tcpdump</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/command/unshare/">unshare</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/linux/linuxsystemprogramming/">LinuxSystemProgramming</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linuxsystemprogramming/file_and_directory_management/">file_and_directory_management</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linuxsystemprogramming/file_io_management/">file_io_management</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linuxsystemprogramming/memory_management/">memory_management</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linuxsystemprogramming/process_capabilities/">process_capabilities</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linuxsystemprogramming/process_management/">process_management</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linuxsystemprogramming/process_credentials/">process_permission</a></li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/linux/linux%E5%9F%BA%E7%A1%80/">Linux基础</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/linux/subsystem/">Subsystem</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/linux/subsystem/udev/">udev</a></li>
  


      </ul>
    </li>
  


      </ul>
    </li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/monitoring/">Monitoring</a></li>
  

  
  
  
  
  
    
    <li>
      <i class="fas fa-plus-circle"></i><a class="" href="/posts/webserver/">WebServer</a>
      
      <ul class="">
        
  
  
  
  
  
    
    <li><a class="" href="/posts/webserver/apache/">Apache</a></li>
  

  
  
  
  
  
    
    <li><a class="" href="/posts/webserver/nginx/">Nginx</a></li>
  


      </ul>
    </li>
  


            </div>
          </ul>
        </div>
      </div>
    </div>
  </section>


      
      
<section class="content-section" id="content-section">
  <div class="content container-fluid" id="content">
    <div class="container-fluid post-card-holder" id="post-card-holder">
      
      
        <div class="post-card">
  <a href="/posts/linux/command/lsof/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">lsof</h5>
        <p class="card-text post-summary">命令格式  lsof [options] [name]
   options: 选项
  name: 文件
  注意点：
  通常多个选项直接是 or 关系，即同时显示多个选项匹配到的内容，要使用 and 关系，添加选项 -a
  -r TIME 不断执行lsof命令，间隔时间为TIME
  显示网络信息  -i [46][protocol][@hostname|hostaddr][:service|port]
   46
  4: IPv4
  6: IPv6
    protocol: TCP|UDP
  hostname|hostaddr: 主机名或地址
  :service|port: 端口或者/etc/services中定义的，比如http, ftp
  示例1： 列出所有TCP/UDP连接
lsof -i 示例2： 列出本地socket连接</p>
      </div>
      <div class="card-footer">
        <span class="float-left">February 3, 2021</span>
        <a
        href="/posts/linux/command/lsof/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/command/iftop/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">iftop</h5>
        <p class="card-text post-summary">安装 yum -y install iftop 使用 启动
iftop 进入界面命令
进入界面后的命令 ------------------ h: 进入帮助命令 L: 显示流量柱状图 主机显示： t: TX流量 / RX流量 / 全部 n: 显示名称 / 不解析名称 s|d: 显示/隐藏源地址 | 显示/隐藏目的地址 端口显示： p: 显示所有端口 N: 显示端口名称 / 不显示端口名称，显示数字 s|d 显示/隐藏源端口 | 显示/隐藏目的端口 排序: 1/2/3: 按第1/2/3列排序 &lt;: 按源地址名称排列 &gt;: 按目的地址名称排列 o: 固定当前排列，不刷新 通用选项： P: 暂停刷新 h: 帮助 </p>
      </div>
      <div class="card-footer">
        <span class="float-left">December 18, 2020</span>
        <a
        href="/posts/linux/command/iftop/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/subsystem/udev/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">udev</h5>
        <p class="card-text post-summary">创建一个脚本，当你插入的计算机插入设备时，触发脚本的执行
 参考文档 技术|udev 入门：管理设备事件的 Linux 子系统
udev简介 当你的计算机插入一个硬件设备，比如网卡，硬盘，U盘，鼠标，键盘，光驱等设备时，内核将给udevd一个udev事件，udevd根据/etc/udev/rules.d/*.rules，/run/udev/rules.d/*.rules, /usr/lib/udev/rule.d/*.rules中定义的规则执行相应的操作，比如给网卡命名，挂载硬盘，或执行一段自定义的脚本。
本文介绍由udev事件触发执行自定义的脚本。比如插入U盘。当理解了udev的工作原理后，可以做很多事情，比如插入一个无线网卡后就安装相应的驱动，插入指定的U盘就执行备份操作。
udevadm命令 udevadm是一个管理udev的工具
udevadm info # Qurey sysfs or the udev database control # Control the udev daemon monitor # Listen to kernel and udev events 示例1： 查看硬盘/dev/sdaudev信息
$ udevadm info -a -n /dev/sda ... KERNEL==&#34;sda&#34; SUBSYSTEM==&#34;block&#34; DRIVER==&#34;&#34; SUBSYSTEMS==&#34;scsi&#34; DRIVERS==&#34;sd&#34; ... 示例2： 查看udev事件
$ udevadm monitor 示例3： 当编写了一个新的udev规则，需要重新加载udev deamon
$ udevadm control --reload udev事件触发脚本执行   编写脚本
$ cat /opt/work/scripts/test.</p>
      </div>
      <div class="card-footer">
        <span class="float-left">November 11, 2020</span>
        <a
        href="/posts/linux/subsystem/udev/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/container/docker/container_concept/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">container_concept</h5>
        <p class="card-text post-summary"></p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 28, 2020</span>
        <a
        href="/posts/container/docker/container_concept/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/container/docker/virtualmachine_container/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">virtualmachine_container</h5>
        <p class="card-text post-summary">虚拟机(Virtual Machine)  通过VMM(Virtual Machine Monitor)或Hypervisor虚拟化软件模拟出多份存储，内存，网络、CPU等物理资源。每一份资源称为一台虚拟机(VM)，原物理机称为宿主机，可以在每台VM上面安装不同于宿主机或彼此的操作系统（宿主机有可能没有OS，被VMM或Hypervisor取代）。
 虚拟机(VM)的用途：   隔离应用： 若将所有应用安装在同一台物理机上面，不同应用进程之间将共享物理资源，但同时也会出现相互干扰（比如资源之间的竞争，或进程访问了部署于自己的数据等安全问题），也不便于管理。虚拟机出现后，可以每台虚拟机上面安装一个应用，这样就完全将应该隔离开来。
  发挥单台物理机的最大性能：有人说那为什么不每台物理机上面安装一个应用呢? 这也是可行的。但现代物理机的性能越来越高，一台物理机安装一个应用有可能使用不完物理资源，造成资源的浪费。此时一台物理机上面安装多台虚拟机，每台虚拟机运行一个应用。就相当于一台物理机上面运行了多个应用，应用之间的进程还是隔离的。
  多操作系统环境： 每台虚拟机可以安装不同的操作系统（Unix, Windows, Linux），这样就可以实现一台物理机上面，通过虚拟软件而运行不同的操作系统，每个应用可以根据需求选择相应的操作系统
  便于应用在不同的物理机上面迁移，保证应用的高可用：传统的模式，若物理机出现问题，不同物理机上面迁移应用由于受到物理机硬件类型的不同而难以实现。而虚拟机解决了这一问题，只要在物理机上面安装相同的VMM或Hypervsor，对于VM来说，就相当于拥有了相同的底层环境，可以方便的在这些Hyperversor上面迁移。从而实现不同物理机上面快速迁移应用的目的。
  虚拟机与物理机的对比图： 容器(Container)  在实现进程隔离方面，容器（Container）采用了与虚拟机完全不同的思路，容器并不虚拟出硬件，所以也没有使用另外的操作系统（OS），而是使用物理机原有的操作系统，通过Linux内核所支持的Namespace和Cgroup技术来实现进程的隔离和资源的限制。
此操作的好处是容器（Container）相较于虚拟机相当轻量，容器甚至可以安装到虚拟机里面，所以容器并不是取代虚拟机，而是另辟蹊径。现在围绕容器的生态现在已经建立起来，并还在不断壮大。
 容器与虚拟机的对比图 IaaS, PaaS, SaaS  云厂商通常为我们提供以下三种模式的服务：
  IaaS(Infrastructure as a Service)：比如AWS的EC2, Google云的VM, 阿里云的ECS等各种云服务器
  PaaS(Platform as a Service): AWS Elastic Beanstalk, Windows Azure, Heroku, Force.com, Google App Engine等各种软件发布平台。
  SaaS(Softer as a Service)：Facebook , 微信，Google Apps等各种应用软件。</p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 27, 2020</span>
        <a
        href="/posts/container/docker/virtualmachine_container/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/linuxsystemprogramming/memory/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">Linux内存管理</h5>
        <p class="card-text post-summary">内存概述  Linux内核并不是将物理内存直接分配给进程，而是采用虚拟内存结构。每个进程拥有一个独立的虚拟内存空间和内存映射表(page table)，虚拟内存到物理内存的地址映射关系记录于page table中，当CPU执行指令时，若该指令是从内存中读取或写入数据时，就需要通过MMU(Memory Manage Unit)将内存virtual address替换为physical address
 物理内存 物理内存根据用途划分为不同的区域，比如：DAM, ZONE_HIGHMEM , ZONE_NORMAL , 每个区域又划分为多个page, page是物理内存进行分配的最小单位，每个page的大小是由CPU架构决定的，有些架构支持多种page size，可以在内核初始化时通过内核配置文件选择其中一种尺寸。默认采用4KB。
若是多颗处理器的机器，内存类型可能是NUMA(Non-Uniform Memory Access)，CPU读取不同内存（是否与自己相邻，相邻的称为该CPU的local memory）的速度是不一样的。与之相对应的UMA读取所有内存速度一样。NUMA将内存划分为不同的bank，每个bank对应一个Node, 每个Node下面分不同区域。
虚拟内存 由于物理内存采用page作为基本单位进行分配，虚拟内存也采用page作为基本单位进行内存的分配。虚拟内存到物理内存的地址映射通过记录于page table中的映射条目完成，每个物理内存页可以映射多个虚拟内存页，这样可以实现不同进程的内存共享。
采用虚拟内存架构可以带来以下好处：
  隔离用户进程和内核进程内存空间，隔离用户进程之间的内存空间：
由于进程使用的时虚拟内存地址，虚拟地址所对应的物理地址是由MMU映射完成的，所以进程无法访问其他进程的内存空间，除非有意共享。
  硬件抽象：
物理内存通常比较复杂，比如多块物理内存，甚至是NUMA，虚拟内存将物理内存的各种细节隐藏，对每个进程抽象出一个统一的虚拟地址空间。 由于内核可以自由的修改虚拟内存到物理内存地址的映射，为了节省物理内存，内核并不及时将虚拟内存映射到物理内存，而是当进程真正使用到了才给其进行映射，使用多少映射多少，这就是延时分配和按需分配。 其次如果物理内存紧张，内核可以将最近没使用，且使用频率不高的占用内存的数据换出到硬盘，使用到时再换出到内存。
  实现内存中的数据移动到硬盘交换分区中
  实现内存区域访问权限控制
  实现物理内存共享，将物理内存page映射到多个进程虚拟地址空间中
  MMU MMU(Memory Manage Unit)是CPU和内存之间的一块硬件，用于virtual-memory-address 到 physical-memory-address的转换，MMU不但实现地址转换，还实现内存权限控制，管理TLB缓存等
为了加快虚拟地址到物理地址的映射速度，CPU使用TLB缓存，TLB访问速度介于CPU和CPU缓存之间，TLB缓存记录了最近的内存地址映射条目，CPU首先查找TLB中是否有映射条目，没有才取查询内存中的page table。
虚拟地址空间 Linux中，不仅是用户空间进程，内核也使用虚拟地址，虚拟地址空间被划分为内核和用户空间，虚拟地址包括以下三部分：
  内核空间   Kernel Logical Address
  Kernel Virtual Address</p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 21, 2020</span>
        <a
        href="/posts/linux/linuxsystemprogramming/memory/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/linuxsystemprogramming/process_capabilities/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">process_capabilities</h5>
        <p class="card-text post-summary">capabilities概述 传统的UNIX系统将进程分为两类：
  provileged特权进程：effective user ID是0的进程，内核对此类进程跳过所有权限检查，即有权限执行任何操作。
  unprivileged非特权进程：effective user ID不是0的进程，内核对此类进程进行全面权限检查，根据effective UID, effective GID, supplementary grop list决定是否有权限执行某项操作。
  传统UNIX对于普通进程执行特权操作就必须使进程的effective user ID为0(通过set-user-ID)，如此进程就拥有了所有特权，若进程执行非法或意外操作将导致严重破坏。为了安全Linux-kernel-2.2后将特权(以前属于effective user ID = 0的)拆分为不同的细小单元。一个单元只拥有一部分特权。这些单元就是capabilities，其实capabilities是属于线程的特性，也就是可以给线程分配不同的capability。
capabilites 列表    capability 名称 描述     CAP_AUDIT_CONTROL 启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则   CAP_AUDIT_READ 允许通过 multicast netlink 套接字读取审计日志   CAP_AUDIT_WRITE 将记录写入内核审计日志   CAP_BLOCK_SUSPEND 使用可以阻止系统挂起的特性   CAP_CHOWN 修改文件所有者的权限   CAP_DAC_OVERRIDE 忽略文件的 DAC 访问限制   CAP_DAC_READ_SEARCH 忽略文件读及目录搜索的 DAC 访问限制   CAP_FOWNER 忽略文件属主 ID 必须和进程用户 ID 相匹配的限制   CAP_FSETID 允许设置文件的 setuid 位   CAP_IPC_LOCK 允许锁定共享内存片段   CAP_IPC_OWNER 忽略 IPC 所有权检查   CAP_KILL 允许对不属于自己的进程发送信号   CAP_LEASE 允许修改文件锁的 FL_LEASE 标志   CAP_LINUX_IMMUTABLE 允许修改文件的 IMMUTABLE 和 APPEND 属性标志   CAP_MAC_ADMIN 允许 MAC 配置或状态更改   CAP_MAC_OVERRIDE 忽略文件的 DAC 访问限制   CAP_MKNOD 允许使用 mknod() 系统调用   CAP_NET_ADMIN 允许执行网络管理任务   CAP_NET_BIND_SERVICE 允许绑定到小于 1024 的端口   CAP_NET_BROADCAST 允许网络广播和多播访问   CAP_NET_RAW 允许使用原始套接字   CAP_SETGID 允许改变进程的 GID   CAP_SETFCAP 允许为文件设置任意的 capabilities   CAP_SETPCAP 参考 capabilities man page   CAP_SETUID 允许改变进程的 UID   CAP_SYS_ADMIN 允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等   CAP_SYS_BOOT 允许重新启动系统   CAP_SYS_CHROOT 允许使用 chroot() 系统调用   CAP_SYS_MODULE 允许插入和删除内核模块   CAP_SYS_NICE 允许提升优先级及设置其他进程的优先级   CAP_SYS_PACCT 允许执行进程的 BSD 式审计   CAP_SYS_PTRACE 允许跟踪任何进程   CAP_SYS_RAWIO 允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备   CAP_SYS_RESOURCE 忽略资源限制   CAP_SYS_TIME 允许改变系统时钟   CAP_SYS_TTY_CONFIG 允许配置 TTY 设备   CAP_SYSLOG 允许使用 syslog() 系统调用   CAP_WAKE_ALARM 允许触发一些能唤醒系统的东西(比如 CLOCK_BOOTTIME_ALARM 计时器)    相关系统调用 cap_t cap_get_proc() // 获取当前进程的capalibities cap_t cap_get_pid(pid_t pid) // 获取指定进程的capalibities cap_t cap_from_text(char *buf_p) // 将文本转化为capablibities char *cap_to_text(cap_t caps, ssize_t *length_p) // 将capalibities转为文本 int cap_from_name(char *name, int *cap_p) // 将字符串表示的capability转为对应的数字 char *cap_to_name(int cap) // 将cap的数字转为文本  int cap_get_flag(cap_t cap_p, cap_value_t cap, cap_flag_t flag, cap_flag_value_t *value_p); // 设置能力，配合cap_set_proc()使用 int cap_set_proc(cap_t cap_p) //设置当前进程的能力 cap_t cap_init() // creates a capability state int cap_free() // 释放capability state内存 获取、修改文件capability的命令 获取文件capabilities</p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 15, 2020</span>
        <a
        href="/posts/linux/linuxsystemprogramming/process_capabilities/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/linuxsystemprogramming/process_credentials/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">进程凭证</h5>
        <p class="card-text post-summary">每个进程都有一套用数字表示的useridentifiers(UIDs)和group identifiers(GIDs)，这些ID称为进程的凭证，决定了进程的权限。
 UIDs和GIDs包含以下几种：
  实际用户ID：real user ID(RUID) 和实际组ID： real group ID(RGID)
  有效用户ID：effective user ID(EUID) 和有效组ID： effective group ID(EGID)
  保存set-user-ID：saved set-user-ID(SUID)和保存set-grop-ID：saved set-group-ID(SGID)
  文件系统用户ID：filesystem user ID(FUID)和文件系统组ID：filesystem group ID(FGID)
  附加组ID: supplementary group IDs
  FUID和FGID通常与EUID和EGID一样，后文不再对其单独叙述。
UIDs, GIDs作用   RUID(RGID): 实际用户(组)ID决定了进程所属的用户和组（可能被进程执行的程序指令改变）。CentOS发行版上，当我们登录bash(即进入bash进程提供的命令行终端）时，登录程序会读取/etc/passwd文件对应用户的第三、第四字段的值作为bash进程的RUID和RGID，我们在bash里面执行的各种命令的RUID和RGID都继承自父进程bash。同样，当创建新进程时，该进程的RUID, RGID也继承自其父进程。
  EUID(EGID): 有效用户(组)ID决定了进程执行各种操作时所拥有的权限，通常EUDI等同于RUID，但以下两种情况会使其不一样：
  当可执行文件（程序或命令）设置了set-user-ID,set-group-ID，则执行该程序时，进程的有效用户(组)ID会被改变为可执行文件的属主ID(属组ID)。若可执行文件属主、属组ID是0(比如root)，则进程就间接拥有了超级权限。
  进程执行了setuid()之类的系统调用，改变了进程的有效用户ID。
    SUID(SGID)：save set-user-ID的初值从EUID复制而来，通常配合set-user-ID标志位使用，设置了该标志位的程序启动后，进程的EUID为程序的属主ID，从而save set-user-ID的值也为程序属主ID，进程通过seteuid()等指令可以自由的将EUID设置为RUID或save set-user-ID。当进程需要执行特权操作时，将EUID设置为save set-user-ID而获得需要的权限，而执行普通操作时，将EUID设置为RUID，降低进程的权限，保证系统安全。</p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 11, 2020</span>
        <a
        href="/posts/linux/linuxsystemprogramming/process_credentials/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/command/ethtool/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">ethtool</h5>
        <p class="card-text post-summary">查询和修改以太网卡的配置信息（网卡驱动层）
命令显示的信息来源于网卡驱动层，即TCP/IP协议的链路层
 语法 ethtool [OPTIONS] DEVNAME OPTIONS -a 查看网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。 -A 修改网卡中 接收模块RX、发送模块TX和Autonegotiate模块的状态：启动on 或 停用off。 -c display the Coalesce information of the specified ethernet card。 -C Change the Coalesce setting of the specified ethernet card。 -g Display the rx/tx ring parameter information of the specified ethernet card。 -G change the rx/tx ring setting of the specified ethernet card。 -i 显示网卡驱动的信息，如驱动的名称、版本等。 -d 显示register dump信息, 部分网卡驱动不支持该选项。 -e 显示EEPROM dump信息，部分网卡驱动不支持该选项。 -E 修改网卡EEPROM byte。 -k 显示网卡Offload参数的状态：on 或 off，包括rx-checksumming、tx-checksumming等。 -K 修改网卡Offload参数的状态。 -p 用于区别不同ethX对应网卡的物理位置，常用的方法是使网卡port上的led不断的闪；N指示了网卡闪的持续时间，以秒为单位。 -r 如果auto-negotiation模块的状态为on，则restarts auto-negotiation。 -S 显示NIC- and driver-specific 的统计参数，如网卡接收/发送的字节数、接收/发送的广播包个数等。 -t 让网卡执行自我检测，有两种模式：offline or online。 -s 修改网卡的部分配置，包括网卡速度、单工/全双工模式、mac地址等。 示例 ethtool devname ethtool -h|--help ethtool --version ethtool -a|--show-pause devname ethtool -A|--pause devname [autoneg on|off] [rx on|off] [tx on|off] ethtool -c|--show-coalesce devname ethtool -g|--show-ring devname ethtool -G|--set-ring devname [rx N] [rx-mini N] [rx-jumbo N] [tx N] ethtool -i|--driver devname ethtool -d|--register-dump devname [raw on|off] [hex on|off] [file name] ethtool -e|--eeprom-dump devname [raw on|off] [offset N] [length N] ethtool -E|--change-eeprom devname [magic N] [offset N] [length N] [value N] ethtool -k|--show-features|--show-offload devname ethtool -K|--features|--offload devname feature on|off .</p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 9, 2020</span>
        <a
        href="/posts/linux/command/ethtool/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/container/network/veth/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">veth</h5>
        <p class="card-text post-summary">概述  veth是Linux的虚拟网卡，和其他虚拟网卡一样，它有两端。不同之处在于veth设备通常成对出现，成对的两个veth设备一端互相连接（类似于一条网线连接两块网卡），另外一端各自连接协议栈。
数据从协议栈流入veth设备后，将从另外一个与之相连的veth设备流出。
 案例  veth设备通常用作容器中，实现容器连通外部网络，容器其实就是通过Namespace和CGroup技术实现进程隔离和限制的进程。
下面演示与主机不在同一个net namespace 的进程如何访问外部网络
若在虚拟机中操作，需要设置虚拟机管理软件网卡开启混杂模式，让目的非本机的mac地址通过虚拟机网卡。
 方法1：通过bridge实现 网络示意图如下所示
netnamespace-01 以下操作均在net-namespace01中
创建网桥br0，并配置网络
ip link add br0 type bridge 启动网桥
ip link set br0 up 将物理网卡enp0s3加入网桥br0中，此时网络会中断，因为enp0s3 上原有的地址会消失，此时enp0s3的功能相当于一根网线，起到将br0与外界连接的作用。
ip link set enp0s3 master br0 br0相当于交换机和网卡的功能，可以在上面配置ip
ip addr add 192.168.0.183/24 dev br0 配置网关地址，DNS，此处均为临时配置。
$ ip route add default via 192.168.0.1 $ echo &#39;nameserver 192.168.0.1&#39; &gt;&gt; /etc/resolv.conf 此时可以正常访问外部网络
创建veth设备
ip link add veth1 type veth peer veth0 激活veth0，并加入网桥br0</p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 9, 2020</span>
        <a
        href="/posts/container/network/veth/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/command/strace/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">strace</h5>
        <p class="card-text post-summary"> strace 最简单的用法是，指定一个要执行的命令，命令结束后它也退出。在命令的执行过程中，strace会记录和解析命令进程的所有系统调用，和该进程收到的信号量。
 语法 strace [OPTIONS] COMMAND 示例 strace -o record.txt -f ls </p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 8, 2020</span>
        <a
        href="/posts/linux/command/strace/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
        <div class="post-card">
  <a href="/posts/linux/command/unshare/" class="post-card-link">
    <div class="card">
      <div class="card-head">
        <img class="card-img-top" src='/assets/images/default-hero.jpg'/>
      </div>
      <div class="card-body">
        <h5 class="card-title">unshare</h5>
        <p class="card-text post-summary">用于Linux Namespace，unshare 命令可以创建一个新的Namespace，然后执行指定的程序，并将新的进程加入到新创建的Namespace中。新的Namespace支持多少种隔离，由unshare选项决定
 语法 unshare [OPTIONS] COMMAND OPTIONS:
  -m, &ndash;mount : CLONE_NEWNS
  -u, &ndash;uts : CLONE_NEWUTS
  -i, &ndash;ipc : CLONE_NEWIPC
  -n, &ndash;net : CLONE_NEWNET
  -p, &ndash;pid : CLONE_NEWPID
  -U, &ndash;user : CLONE_NEWUSER
  -f, &ndash;fork : 创建一个子进程执行COMMAND，而不是取代当前的进程
  -r, &ndash;map-root-user : 必须有-U选项，新命名空间中的用户为root
  &ndash;propagation slave|shared|private|unchanged : 挂载选项
  &ndash;mount-proc : 新的Namespace中重新挂载proc，前提有-m选项。
  示例 创建一个各命名空间都隔离的Namespace，行Namespace执行bash程序</p>
      </div>
      <div class="card-footer">
        <span class="float-left">September 8, 2020</span>
        <a
        href="/posts/linux/command/unshare/"
        class="float-right btn btn-outline-info btn-sm"
        >Read</a
        >
      </div>
    </div>
  </a>
</div>

      
    </div>
    <div class="paginator">
      
<ul class="pagination">
  <li class="page-item">
    <a href="/posts/" class="page-link" aria-label="First"><span aria-hidden="true">&laquo;&laquo;</span></a>
  </li>
  <li class="page-item disabled">
    <a  class="page-link" aria-label="Previous"><span aria-hidden="true">&laquo;</span></a>
  </li>
  <li class="page-item active">
    <a class="page-link" href="/posts/">1</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/page/2/">2</a>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/page/3/">3</a>
  </li>
  <li class="page-item disabled">
    <span aria-hidden="true">&nbsp;&hellip;&nbsp;</span>
  </li>
  <li class="page-item">
    <a class="page-link" href="/posts/page/5/">5</a>
  </li>
  <li class="page-item">
    <a href="/posts/page/2/" class="page-link" aria-label="Next"><span aria-hidden="true">&raquo;</span></a>
  </li>
  <li class="page-item">
    <a href="/posts/page/5/" class="page-link" aria-label="Last"><span aria-hidden="true">&raquo;&raquo;</span></a>
  </li>
</ul>


    </div>
  </div>
</section>


      
       
    </div>

    <footer class="container-fluid text-center align-content-center footer pb-2">
  <div class="container pt-5">
    <div class="row text-left">
      <div class="col-md-4 col-sm-12">
        <h5>Navigation</h5>
        
        <ul>
            
            <li class="nav-item">
              <a class="smooth-scroll" href="/#links">Links</a>
            </li>
            
        </ul>
        

      </div>
      <div class="col-md-4 col-sm-12">
        <h5>Contact Me</h5>
        <ul>
          
          <li><span>Email: </span> <span>zhubiaook@outlook.com</span></li>
          
        </ul>
      </div>
      
    </div>
  </div>
  <hr />
  <div class="container">
    <div class="row text-left">
      <div class="col-md-4">
        <a id="theme" href="https://github.com/hossainemruz/toha" target="#">
          <img src="/assets/images/inverted-logo.png">
          Toha
        </a>
      </div>
      <div class="col-md-4 text-center">© 2020 Copyright.</div>
      <div class="col-md-4 text-right">
        <a id="hugo" href="https://gohugo.io/">Powered by Hugo
        <img
          src="/assets/images/hugo-logo-wide.svg"
          alt="Hugo Logo"
          height="18"
        />
        </a>
      </div>
    </div>
  </div>
</footer>

    <script src="/assets/js/jquery-3.4.1.min.js"></script>
<script src="/assets/js/bootstrap.min.js"></script>

<script src="/assets/js/navbar.js"></script>
<script src="/assets/js/main.js"></script>


    
    
    <script src="/assets/js/list.js"></script>

  </body>
</html>
